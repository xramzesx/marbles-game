/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/decorators.ts":
/*!***************************!*\
  !*** ./src/decorators.ts ***!
  \***************************/
/*! exports provided: log, popOut, time, mark */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"log\", function() { return log; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"popOut\", function() { return popOut; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"time\", function() { return time; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mark\", function() { return mark; });\n/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaults */ \"./src/defaults.ts\");\n/* harmony import */ var _voids__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./voids */ \"./src/voids.ts\");\n\r\n\r\nlet current_time = \"00:00:00\";\r\nfunction log(target, name, descriptor) {\r\n    const originalMethod = descriptor.value;\r\n    descriptor.value = function (...args) {\r\n        const result = originalMethod.apply(this, args);\r\n        if (name == 'drawBalls') {\r\n            const drawedBalls = document.getElementById('drawed-balls');\r\n            drawedBalls.innerHTML = \"\";\r\n            console.log(result);\r\n            for (const { color: col } of result) {\r\n                const ball = document.createElement('div');\r\n                const color = _defaults__WEBPACK_IMPORTED_MODULE_0__[\"default\"].colors[col];\r\n                ball.classList.add('matrix__ball--show');\r\n                ball.style.backgroundColor = color;\r\n                ball.style.filter = `drop-shadow( .2rem .2rem 0 ${color})`;\r\n                drawedBalls.appendChild(ball);\r\n            }\r\n        }\r\n        if (name == '_timeoutedHitBall') {\r\n            document.getElementById('points').innerHTML = `${result}`;\r\n        }\r\n        if (name == 'timer') {\r\n            document.getElementById('time').innerHTML = `${current_time}`;\r\n        }\r\n        // console.log(`Wywoluje : ${name}, oto rezultat ${result}`)\r\n        return result;\r\n    };\r\n}\r\nconst stonogaIco = document.createElement('img');\r\nstonogaIco.src = './favicon.png';\r\nstonogaIco.classList.add('icon');\r\nconst mockers = [\r\n    'bruh',\r\n    'no i co robisz cieniasie',\r\n    'postarałbyś się',\r\n    'boże co za gość',\r\n    'no lepiej tą kulke przesuń no',\r\n    stonogaIco.outerHTML\r\n];\r\nlet canPopOut = true;\r\nfunction popOut(target, name, descriptor) {\r\n    const originalMethod = descriptor.value;\r\n    descriptor.value = function (...args) {\r\n        const result = originalMethod.apply(this, args);\r\n        const popOutDiv = document.createElement('div');\r\n        popOutDiv.classList.add('overlay__pop-out');\r\n        if (result.length) {\r\n            popOutDiv.innerHTML = `oj +${result.length} byczq`;\r\n        }\r\n        else {\r\n            popOutDiv.innerHTML = mockers[Object(_voids__WEBPACK_IMPORTED_MODULE_1__[\"getRandom\"])(0, mockers.length)];\r\n        }\r\n        if (canPopOut || result.length) {\r\n            document.getElementById('pop-out').append(popOutDiv);\r\n            canPopOut = false;\r\n            setTimeout(() => {\r\n                canPopOut = true;\r\n            }, 1000);\r\n        }\r\n        setTimeout(() => {\r\n            popOutDiv.remove();\r\n        }, 2000);\r\n        return result;\r\n    };\r\n}\r\nfunction time(target, name, descriptor) {\r\n    const originalMethod = descriptor.value;\r\n    descriptor.value = function (...args) {\r\n        const result = originalMethod.apply(this, args);\r\n        console.log(result, 'dasdas');\r\n        let sec_num = parseInt(`${result}`, 10); // don't forget the second param\r\n        let hours = Math.floor(sec_num / 3600);\r\n        let minutes = Math.floor((sec_num - (hours * 3600)) / 60);\r\n        let seconds = sec_num - (hours * 3600) - (minutes * 60);\r\n        if (hours < 10) {\r\n            hours = \"0\" + hours;\r\n        }\r\n        if (minutes < 10) {\r\n            minutes = \"0\" + minutes;\r\n        }\r\n        if (seconds < 10) {\r\n            seconds = \"0\" + seconds;\r\n        }\r\n        current_time = hours + ':' + minutes + ':' + seconds;\r\n        // current_time = pad(hours, 2) + ':' + pad(minutes, 2) + ':' + pad(seconds, 2) + ',' + pad(milliseconds, 3);\r\n        return current_time;\r\n        // return timeString\r\n    };\r\n}\r\nfunction mark(target, name, descriptor) {\r\n    const originalMethod = descriptor.value;\r\n    descriptor.value = function (...args) {\r\n        const result = originalMethod.apply(this, args);\r\n        if (name == 'isAnyCrossSection') {\r\n        }\r\n        return result;\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack:///./src/decorators.ts?");

/***/ }),

/***/ "./src/defaults.ts":
/*!*************************!*\
  !*** ./src/defaults.ts ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return defaults; });\n/* harmony import */ var _voids__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./voids */ \"./src/voids.ts\");\n\r\n//// CONFIGURATION PROPS WITH VOIDS ////\r\nclass Voids {\r\n    generateBorderMap(x, y) {\r\n        const borderMap = [];\r\n        for (let i = 0; i < y; i++) {\r\n            const rows = [];\r\n            for (let j = 0; j < x; j++)\r\n                rows.push(0);\r\n            borderMap.push(rows);\r\n        }\r\n        return borderMap;\r\n    }\r\n    resetBorders(arr) {\r\n        for (let i in arr) {\r\n            for (let j in arr[i])\r\n                arr[i][j] = 0;\r\n        }\r\n    }\r\n    generateRandomBorders(arr, maxBordes = 3) {\r\n        const { length: height } = arr;\r\n        const { length: width } = arr[0];\r\n        for (let i = 0; i < maxBordes; i++) {\r\n            let x;\r\n            let y;\r\n            let repeats = 0;\r\n            do {\r\n                if (repeats > 5)\r\n                    break;\r\n                y = Object(_voids__WEBPACK_IMPORTED_MODULE_0__[\"getRandom\"])(0, height);\r\n                x = Object(_voids__WEBPACK_IMPORTED_MODULE_0__[\"getRandom\"])(0, width);\r\n            } while (arr[y][x] == -1);\r\n            if (repeats > 5) {\r\n                //// add some kind of validation\r\n                break;\r\n            }\r\n            arr[y][x] = -1;\r\n        }\r\n    }\r\n}\r\nclass defaults {\r\n}\r\ndefaults.size = {\r\n    x: 9,\r\n    y: 9\r\n};\r\ndefaults.maxBorders = 3;\r\ndefaults.colors = [\r\n    'red',\r\n    'darkgreen',\r\n    'papayawhip',\r\n    'blue',\r\n    'yellow',\r\n    'purple',\r\n    '#111532'\r\n];\r\ndefaults.allSides = [\r\n    { x: 0, y: 1 },\r\n    { x: 1, y: 1 },\r\n    { x: 1, y: 0 },\r\n    { x: 1, y: -1 },\r\n    { x: 0, y: -1 },\r\n    { x: -1, y: -1 },\r\n    { x: -1, y: 0 },\r\n    { x: -1, y: 1 },\r\n];\r\ndefaults.voids = new Voids;\r\n// export default {\r\n//     size : {\r\n//         x : 9,\r\n//         y : 9\r\n//     },\r\n//     /// max borders and max ball count to draw\r\n//     maxBorders : 3,\r\n//     colors : [\r\n//         'red',\r\n//         'darkgreen',\r\n//         'papayawhip',\r\n//         'blue',\r\n//         'yellow',\r\n//         'purple',\r\n//         '#111532'\r\n//     ],\r\n//     allSides : [\r\n//         { x : 0,  y : 1  },\r\n//         { x : 1,  y : 1  },\r\n//         { x : 1,  y : 0  },\r\n//         { x : 1,  y : -1 },\r\n//         { x : 0,  y : -1 },\r\n//         { x : -1, y : -1 },\r\n//         { x : -1, y : 0  },\r\n//         { x : -1, y : 1  },\r\n//     ],\r\n//     voids : {        \r\n//         generateBorderMap : (x : number, y : number) : number[][] => {\r\n//             const borderMap = []\r\n//             for ( let i : number = 0; i < y; i++ ){\r\n//                 const rows = []\r\n//                 for (let j : number = 0; j < x ; j++)\r\n//                     rows.push(0)\r\n//                 borderMap.push(rows)\r\n//             }\r\n//             return borderMap\r\n//         },\r\n//         resetBorders : ( arr : any[] ) : void => {\r\n//             for ( let i in arr ) {\r\n//                 for (let j in arr[i])\r\n//                     arr[i][j] = 0\r\n//             }\r\n//         },\r\n//         generateRandomBorders : ( arr : number[][], maxBordes : number = 3 ) : void => {\r\n//             const { length : height } = arr\r\n//             const { length : width } = arr[0]\r\n//             for ( let i = 0; i < maxBordes; i++ ) {\r\n//                 let x : number\r\n//                 let y : number\r\n//                 let repeats = 0\r\n//                 do {\r\n//                     if (repeats > 5)\r\n//                         break\r\n//                     y = getRandom( 0, height )\r\n//                     x = getRandom( 0, width )\r\n//                 } while ( arr[ y ][ x ] == -1 )\r\n//                 if (repeats > 5) {\r\n//                     //// add some kind of validation\r\n//                     break\r\n//                 }\r\n//                 arr[ y ][ x ] = -1\r\n//             }\r\n//         },\r\n//     },\r\n// }\r\n\n\n//# sourceURL=webpack:///./src/defaults.ts?");

/***/ }),

/***/ "./src/game/Board.ts":
/*!***************************!*\
  !*** ./src/game/Board.ts ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Board; });\n/* harmony import */ var _decorators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../decorators */ \"./src/decorators.ts\");\n/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../defaults */ \"./src/defaults.ts\");\n/* harmony import */ var _pathfind_Matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pathfind/Matrix */ \"./src/pathfind/Matrix.ts\");\n/* harmony import */ var _voids__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../voids */ \"./src/voids.ts\");\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (undefined && undefined.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nconsole.log('loaded : Board.ts');\r\n\r\n\r\n\r\n\r\nclass Board extends _pathfind_Matrix__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\r\n    constructor(props) {\r\n        super(props);\r\n        this._path = {\r\n            checked: [],\r\n            path: []\r\n        };\r\n        this._drawedBalls = [];\r\n        this._checkedNodes = [];\r\n        this._matchedNodes = [];\r\n        this._time = 0;\r\n        this._isStopped = false;\r\n        this._points = 0;\r\n        this.stage = 0;\r\n        // this.drawBalls()\r\n        this.timer = this.timer.bind(this);\r\n        this.timer = this.timer.bind(this);\r\n        this._timeoutedHitBall = this._timeoutedHitBall.bind(this);\r\n        this._timeoutedSelectMatched = this._timeoutedSelectMatched.bind(this);\r\n        this.gameOver = this.gameOver.bind(this);\r\n    }\r\n    //// OVERRIDE ////\r\n    findPath(end) {\r\n        if (super.start) {\r\n            if (this._path.checked)\r\n                this._path.checked.filter(checked => { super.find(checked).reset(); });\r\n            // for ( let i in this._path.checked ) {\r\n            //     this._path.checked[i].reset()\r\n            // }\r\n            if (this._path.path)\r\n                this._path.path.filter(path => { super.find(path).reset(); });\r\n            // for ( let i in this._path.path ) {\r\n            //     this._path.path[i].reset()\r\n            // }\r\n            this._path = super.findPath(super.start, end);\r\n            if (this._path.path)\r\n                this._path.path.filter(field => {\r\n                    super.find(field).classList.add('matrix__field--path');\r\n                });\r\n            else\r\n                this.forceRefresh();\r\n        }\r\n        super.start.classList.add('matrix__field--start');\r\n        return this._path;\r\n    }\r\n    //// GAME BASIC ////\r\n    hit(field) {\r\n        super.borders[field.y][field.x] = 0;\r\n        const currentField = super.find(field);\r\n        currentField.reset();\r\n        currentField.ball = { color: -1 };\r\n    }\r\n    move(field) {\r\n        if (this._path.path) {\r\n            if (!this._timeInterval) {\r\n                this._timeInterval = setInterval(this.timer, 1000);\r\n            }\r\n            const start = super.start;\r\n            super.borders[start.y][start.x] = 0;\r\n            super.borders[field.y][field.x] = -1;\r\n            super.fields[field.y][field.x].ball = Object.assign({}, super.fields[start.y][start.x].ball);\r\n            super.fields[start.y][start.x].ball = {\r\n                color: -1\r\n            };\r\n            super.end = field;\r\n            //// call checking functions ////\r\n            return true;\r\n        }\r\n        else\r\n            return false;\r\n    }\r\n    drawBalls(count = _defaults__WEBPACK_IMPORTED_MODULE_1__[\"default\"].maxBorders) {\r\n        const result = [];\r\n        for (let i = 0; i < count; i++) {\r\n            result.push({\r\n                color: Object(_voids__WEBPACK_IMPORTED_MODULE_3__[\"getRandom\"])(0, _defaults__WEBPACK_IMPORTED_MODULE_1__[\"default\"].colors.length)\r\n            });\r\n        }\r\n        this._drawedBalls = result;\r\n        return result;\r\n    }\r\n    isAnyCrossSection(drawedBalls = []) {\r\n        let points = 0;\r\n        let result = [];\r\n        let positionResult = [];\r\n        const balls = drawedBalls.map(pos => super.find(pos));\r\n        balls.push(this.end);\r\n        console.log();\r\n        const { allSides: sides } = _defaults__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\r\n        let index = 0;\r\n        for (const ball of balls) {\r\n            index++;\r\n            if (ball)\r\n                for (let j = 0; j < sides.length / 2; j++) {\r\n                    console.log(\"sides:\", j, (j + sides.length / 2) % sides.length);\r\n                    const checked = [\r\n                        ...this.checkLine(ball, sides[j], ball.color),\r\n                        ...this.checkLine(ball, sides[(j + sides.length / 2) % sides.length], ball.color),\r\n                        ball\r\n                    ];\r\n                    if (checked.length >= 5) {\r\n                        console.warn('wincyj');\r\n                        // for (const field of checked ){\r\n                        //     console.log('x',field.x,'y', field.y)\r\n                        //     field.html.style.background = defaults.colors[ index ]\r\n                        // }\r\n                        checked.filter(node => positionResult.push(node.position));\r\n                        // result = [ ...result, ...checked ]\r\n                    }\r\n                    console.log('checkeeed', checked);\r\n                }\r\n        }\r\n        // this.drawed.filter( pos => {console.log(pos)} )\r\n        // const allNewBalls : PathNode[] = this.drawed.map( position => {\r\n        //     return super.find( position )\r\n        // } )\r\n        const positionSet = new Set(positionResult.map(position => JSON.stringify(position)));\r\n        // console.log(positionSet)\r\n        result = Array.from(positionSet).map(position => this.find(JSON.parse(position)));\r\n        // console.log(\"no repeats result\" , result)\r\n        this._checkedNodes = result;\r\n        return result;\r\n    }\r\n    checkLine(node, direction, color) {\r\n        const shiftedPosition = {\r\n            x: +node.x + direction.x,\r\n            y: +node.y + direction.y\r\n        };\r\n        if (this.isOnBoard(shiftedPosition) &&\r\n            this.isBorder(shiftedPosition)) {\r\n            const currentNode = this.find(shiftedPosition);\r\n            if (currentNode.color == color) {\r\n                console.log('colorki : ', currentNode.color, color);\r\n                return [currentNode, ...this.checkLine(currentNode, direction, color)];\r\n            }\r\n            else {\r\n                //// raczej nic tu nie trzeba ////\r\n                // return [ currentNode ]\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n    getFreeFieldsPositions() {\r\n        const freePositions = [];\r\n        for (let i in this.borders)\r\n            for (let j in this.borders[i])\r\n                if (this.borders[i][j] == 0) {\r\n                    console.log('fp', i, j);\r\n                    freePositions.push({\r\n                        x: +j,\r\n                        y: +i\r\n                    });\r\n                }\r\n        return freePositions;\r\n    }\r\n    countFreeFields() {\r\n        let result = 0;\r\n        for (const row of this.borders)\r\n            for (const value of row)\r\n                if (value == 0)\r\n                    result++;\r\n        console.table(this.borders);\r\n        return result;\r\n    }\r\n    gameOver() {\r\n        //// GAME OVER ////\r\n        document.getElementById('overlay').style.pointerEvents = \"all\";\r\n        const gameOver = document.getElementById('gameover');\r\n        clearInterval(this._timeInterval);\r\n        this._timeInterval = undefined;\r\n        gameOver.className = 'gameover--show';\r\n        // console.log('i tu powinno działać',1)\r\n        document.getElementById('gameover__points').innerHTML = `${this.points}`;\r\n        document.getElementById('gameover__time').innerHTML = `${this.convert()}`;\r\n        this.time = 0;\r\n    }\r\n    convert() {\r\n        return this._time;\r\n    }\r\n    timer() {\r\n        this._time++;\r\n        console.log(this._time);\r\n        return this._time;\r\n    }\r\n    // @log\r\n    generateNewBalls(count = _defaults__WEBPACK_IMPORTED_MODULE_1__[\"default\"].maxBorders, isTimeout = true) {\r\n        // const freeFields : number = this.countFreeFields()\r\n        // const freeFields : PathNode[] = this.getFreeFieldsPositions().map( position => this.find(position) )\r\n        const freeFields = this.getFreeFieldsPositions();\r\n        console.log(freeFields, 'free fields');\r\n        //// NEW WAY ////\r\n        let crossections = [];\r\n        /// checking if there's a crossections ///\r\n        crossections = this.isAnyCrossSection();\r\n        for (const ball of crossections) {\r\n            console.log('pilka', ball);\r\n            ball.classList.add('matrix__field--matched');\r\n        }\r\n        if (isTimeout) {\r\n            setTimeout(() => {\r\n                console.log('timeout 316');\r\n                this._timeoutedSelectMatched(count, crossections, freeFields, isTimeout);\r\n            }, 500);\r\n        }\r\n        else {\r\n            this._timeoutedSelectMatched(count, crossections, freeFields, isTimeout);\r\n        }\r\n    }\r\n    _timeoutedSelectMatched(count, crossections, freeFields, isTimeout) {\r\n        let balls = [];\r\n        if (freeFields.length > 3) {\r\n            for (const ball of this._drawedBalls) {\r\n                const index = Object(_voids__WEBPACK_IMPORTED_MODULE_3__[\"getRandom\"])(0, freeFields.length);\r\n                const position = Object.assign({}, freeFields[index]);\r\n                super.find(position).ball = ball;\r\n                balls.push(position);\r\n                this.borders[position.y][position.x] = -1;\r\n                console.log(position.x, position.y, 'balls 301');\r\n                freeFields.splice(index, 1);\r\n            }\r\n        }\r\n        crossections = this.isAnyCrossSection(balls);\r\n        for (const ball of crossections) {\r\n            console.log('pilka', ball);\r\n            ball.classList.add('matrix__field--matched');\r\n        }\r\n        if (isTimeout) {\r\n            setTimeout(() => {\r\n                console.log('timeout 316');\r\n                this._timeoutedHitBall(count, crossections, freeFields);\r\n            }, 500);\r\n        }\r\n        else {\r\n            this._timeoutedHitBall(count, crossections, freeFields);\r\n        }\r\n        return;\r\n    }\r\n    _timeoutedHitBall(count, crossections, freeFields) {\r\n        for (const field of crossections) {\r\n            this.hit(field);\r\n        }\r\n        /// refreshing ///\r\n        this.resetBorders();\r\n        this.points += crossections.length;\r\n        if (freeFields.length > 3) {\r\n            console.log(this.drawBalls(count));\r\n            this.stage++;\r\n        }\r\n        else {\r\n            ('no i przegrałeś');\r\n            this.gameOver();\r\n        }\r\n        this.isGameStopped = false;\r\n        console.log('pkt', this.points);\r\n        return this.points;\r\n    }\r\n    //// VISUAL EFFECTS ////\r\n    forceRefresh() {\r\n        for (const row of super.fields)\r\n            for (const field of row)\r\n                field.reset();\r\n    }\r\n    //// BOOLS ////\r\n    checkNeighbours(node) {\r\n        const neighbours = [\r\n            { x: 0, y: -1 },\r\n            { x: 1, y: 0 },\r\n            { x: 0, y: 1 },\r\n            { x: -1, y: 0 }\r\n        ];\r\n        for (const { x, y } of neighbours) {\r\n            const pos = {\r\n                y: +node.y + y,\r\n                x: +node.x + x\r\n            };\r\n            if (super.isOnBoard(pos))\r\n                if (!super.fields[pos.y][pos.x].isBorder)\r\n                    return true;\r\n        }\r\n        return false;\r\n    }\r\n    //// SETTERS ////\r\n    // @log\r\n    set path(path) {\r\n        this._path = path;\r\n    }\r\n    set points(points) {\r\n        this._points = points;\r\n    }\r\n    set start(start) {\r\n        if (super.start)\r\n            super.start.classList.remove('matrix__field--start');\r\n        super.start = start;\r\n        if (super.start)\r\n            super.start.classList.add('matrix__field--start');\r\n    }\r\n    set end(end) {\r\n        super.end = end;\r\n    }\r\n    set onGameStopped(callback) {\r\n        this._onGameStopped = callback;\r\n    }\r\n    set isGameStopped(v) {\r\n        this._onGameStopped(v);\r\n        this._isStopped = v;\r\n    }\r\n    set time(v) {\r\n        if (v == 0) {\r\n            clearInterval(this._timeInterval);\r\n            this._timeInterval = undefined;\r\n        }\r\n        this._time = v;\r\n    }\r\n    //// GETTERS ////\r\n    get start() { return super.start; }\r\n    get end() { return super.end; }\r\n    get points() { return this._points; }\r\n    get time() { return this._time; }\r\n    get path() { return this._path; }\r\n    get drawed() { return this._drawedBalls; }\r\n    get matched() { return this._matchedNodes; }\r\n    get isGameStopped() { return this._isStopped; }\r\n}\r\n__decorate([\r\n    _decorators__WEBPACK_IMPORTED_MODULE_0__[\"log\"],\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Number]),\r\n    __metadata(\"design:returntype\", Array)\r\n], Board.prototype, \"drawBalls\", null);\r\n__decorate([\r\n    _decorators__WEBPACK_IMPORTED_MODULE_0__[\"popOut\"],\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Array]),\r\n    __metadata(\"design:returntype\", Array)\r\n], Board.prototype, \"isAnyCrossSection\", null);\r\n__decorate([\r\n    _decorators__WEBPACK_IMPORTED_MODULE_0__[\"time\"],\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", []),\r\n    __metadata(\"design:returntype\", void 0)\r\n], Board.prototype, \"convert\", null);\r\n__decorate([\r\n    _decorators__WEBPACK_IMPORTED_MODULE_0__[\"time\"],\r\n    _decorators__WEBPACK_IMPORTED_MODULE_0__[\"log\"],\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", []),\r\n    __metadata(\"design:returntype\", Object)\r\n], Board.prototype, \"timer\", null);\r\n__decorate([\r\n    _decorators__WEBPACK_IMPORTED_MODULE_0__[\"log\"],\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Number, Array, Array]),\r\n    __metadata(\"design:returntype\", Number)\r\n], Board.prototype, \"_timeoutedHitBall\", null);\r\n\n\n//# sourceURL=webpack:///./src/game/Board.ts?");

/***/ }),

/***/ "./src/main/index.ts":
/*!***************************!*\
  !*** ./src/main/index.ts ***!
  \***************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _game_Board__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Board */ \"./src/game/Board.ts\");\n/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../defaults */ \"./src/defaults.ts\");\n/* harmony import */ var _voids__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../voids */ \"./src/voids.ts\");\nconsole.log('loaded : index.ts');\r\n\r\n\r\n\r\n//// MAIN VOIDS ////\r\nconst { generateBorderMap, resetBorders, generateRandomBorders } = _defaults__WEBPACK_IMPORTED_MODULE_1__[\"default\"].voids;\r\n//// SETUP ////\r\nconst { size, maxBorders } = _defaults__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\r\nconst borders = generateBorderMap(size.x, size.y);\r\nconst board = new _game_Board__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\r\n    width: size.x,\r\n    height: size.y,\r\n    generateHtml: true,\r\n    borders: borders\r\n});\r\nlet isClicked = false;\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n    document.getElementById('board').appendChild(board.html);\r\n    board.onGameStopped = isStopped => {\r\n        // if (isStopped) {\r\n        //     board.html.style.pointerEvents = 'none'\r\n        // } else {\r\n        //     board.html.style.pointerEvents = ''\r\n        // }\r\n        console.log('isStopped', isStopped);\r\n    };\r\n    board.html.classList.add('matrix--hide-field-info');\r\n    board.drawBalls();\r\n    nextStage(false);\r\n    board.html.addEventListener('mouseleave', e => {\r\n        if (!board.isGameStopped)\r\n            board.forceRefresh();\r\n        board.start = board.start;\r\n    });\r\n    board.addEventListener('mouseenter', (e, that) => {\r\n        console.log(that.position);\r\n        if (isClicked) {\r\n            const { path, checked } = board.findPath(that);\r\n            // board.start = board.start\r\n        }\r\n    });\r\n    board.addEventListener('click', (e, that) => {\r\n        console.log(board.isGameStopped);\r\n        if (!board.isGameStopped) {\r\n            if (that.isBorder) {\r\n                /// balls ///\r\n                console.log(board.start, that);\r\n                if (!Object(_voids__WEBPACK_IMPORTED_MODULE_2__[\"compareObj\"])(board.start, that)) {\r\n                    if (board.checkNeighbours(that)) {\r\n                        board.start = that;\r\n                        isClicked = true;\r\n                    }\r\n                }\r\n                else {\r\n                    if (!isClicked) {\r\n                        isClicked = false;\r\n                    }\r\n                    else {\r\n                        console.log('ej no siema mordo');\r\n                        board.start = undefined;\r\n                        isClicked = false;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                /// empty fields ///\r\n                if (isClicked && board.move(that)) {\r\n                    // board.move( that )\r\n                    nextStage();\r\n                }\r\n                board.start = undefined;\r\n                isClicked = false;\r\n            }\r\n            stylizeClick(isClicked);\r\n        }\r\n    });\r\n    const showFieldInfo = document.getElementById('show-field-info');\r\n    const showFieldInfoBtn = document.getElementById('show-field-info-btn');\r\n    showFieldInfoBtn.addEventListener('click', e => {\r\n        console.log(e.target);\r\n        const val = showFieldInfo.getAttribute('value');\r\n        // e.target\r\n        const isTrue = val == \"true\";\r\n        const attr = isTrue ? \"false\" : \"true\";\r\n        showFieldInfo.checked = isTrue;\r\n        if (isTrue) {\r\n            board.html.classList.add('matrix--hide-field-info');\r\n        }\r\n        else {\r\n            board.html.classList.remove('matrix--hide-field-info');\r\n        }\r\n        showFieldInfo.setAttribute('value', attr);\r\n        // showFieldInfo.setAttribute('value')\r\n    });\r\n    document.getElementById('replay').addEventListener('click', e => {\r\n        //// reset and replay ////\r\n        const gameOver = document.getElementById('gameover');\r\n        // gameOver.classList.remove('gameover--show')\r\n        // gameOver.classList.add('gameover--hide')\r\n        gameOver.className = 'gameover--hide';\r\n        document.getElementById('overlay').style.pointerEvents = '';\r\n        resetGame();\r\n    });\r\n    document.getElementById('reset-game').addEventListener('click', resetGame);\r\n});\r\n//// LOCAL VOIDS ////\r\nconst resetGame = () => {\r\n    resetBorders(borders);\r\n    board.reset();\r\n    board.points = 0;\r\n    board.stage = 0;\r\n    board.path = {\r\n        path: [],\r\n        checked: []\r\n    };\r\n    board.time = 0;\r\n    document.getElementById('points').innerHTML = `${0}`;\r\n    document.getElementById('time').innerHTML = `00:00:00`;\r\n    board.drawBalls();\r\n    nextStage(false);\r\n};\r\nconst nextStage = (shift = true) => {\r\n    /// shifting ball ///\r\n    // if ( shift ) {\r\n    // }\r\n    /// generate new balls ///\r\n    // generateRandomBorders( borders, maxBorders )\r\n    // /// refreshing ///\r\n    // board.resetBorders()\r\n    if (shift)\r\n        board.isGameStopped = true;\r\n    else\r\n        board.isGameStopped = false;\r\n    board.generateNewBalls(undefined, shift);\r\n    const path = board.path.path.map(pos => {\r\n        console.log(pos);\r\n        const field = board.find(pos);\r\n        field.classList.add('matrix__field--dimmed-path');\r\n        return field;\r\n    });\r\n    if (board.start) {\r\n        board.start.classList.add('matrix__field--dimmed-path');\r\n        path.push(board.start);\r\n    }\r\n    const currentStage = JSON.parse(`${board.stage}`);\r\n    // console.log(currentStage)\r\n    let time = Date.now();\r\n    setTimeout(() => {\r\n        if (currentStage == board.stage) {\r\n            path.filter(field => {\r\n                field.classList.remove('matrix__field--dimmed-path');\r\n            });\r\n            board.isGameStopped = false;\r\n            console.log(Date.now() - time, 'time');\r\n        }\r\n        // board.isGameStopped = false\r\n    }, 1000);\r\n    stylizeClick(isClicked);\r\n};\r\nconst restyle = (style, html) => {\r\n    if (!html)\r\n        document.getElementById('style').innerHTML = style;\r\n    else\r\n        html.innerHTML = style;\r\n};\r\nconst stylizeClick = (isClicked) => {\r\n    restyle(`\r\n            .matrix__field {\r\n                ${isClicked\r\n        ? 'cursor:pointer'\r\n        : ''}\r\n            }\r\n\r\n            .matrix__field--border {\r\n                ${isClicked\r\n        ? 'cursor:default'\r\n        : 'cursor:pointer;'}\r\n            }\r\n        `, document.getElementById('cursor-style'));\r\n};\r\n\n\n//# sourceURL=webpack:///./src/main/index.ts?");

/***/ }),

/***/ "./src/pathfind/Matrix.ts":
/*!********************************!*\
  !*** ./src/pathfind/Matrix.ts ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Matrix; });\n/* harmony import */ var _voids__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../voids */ \"./src/voids.ts\");\n/* harmony import */ var _Node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Node */ \"./src/pathfind/Node.ts\");\nconsole.log('loaded : Matrix.ts');\r\n\r\n\r\nclass Matrix {\r\n    //// MAIN ////\r\n    constructor(props) {\r\n        //// VARS ////\r\n        /// board size ///\r\n        this._height = 1;\r\n        this._width = 1;\r\n        /// html board ///\r\n        this._html = {\r\n            generate: false,\r\n            main: document.createElement('div')\r\n        };\r\n        this._width = props.width || this._width;\r\n        this._height = props.height || this._height;\r\n        this._html.generate = props.generateHtml || this._html.generate;\r\n        this._borders = props.borders || this._borders;\r\n        this._init();\r\n    }\r\n    //// VOIDS ////\r\n    _init() {\r\n        this._fields = [];\r\n        const { _width, _height } = this;\r\n        for (let i = 0; i < _width; i++) {\r\n            const fieldRow = [];\r\n            for (let j = 0; j < _height; j++) {\r\n                fieldRow.push(new _Node__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\r\n                    x: j,\r\n                    y: i,\r\n                    generate: this._html.generate\r\n                }));\r\n            }\r\n            this._fields.push(fieldRow);\r\n        }\r\n        this.reset();\r\n        if (this._html.generate)\r\n            this.generateHtml();\r\n    }\r\n    //// RESET AND REFRESH ////\r\n    reset() {\r\n        for (const row of this._fields) {\r\n            for (const child of row) {\r\n                child.reset();\r\n            }\r\n        }\r\n        this.resetBorders();\r\n    }\r\n    resetBorders() {\r\n        const fields = this._fields;\r\n        const borders = this._borders;\r\n        for (let i in borders) {\r\n            for (let j in borders[i]) {\r\n                fields[i][j].isBorder = !!borders[i][j];\r\n                if (this._html.generate)\r\n                    fields[i][j].reset();\r\n            }\r\n        }\r\n    }\r\n    //// HTML ////\r\n    generateHtml() {\r\n        /// add class ///\r\n        this.html.classList.add('matrix');\r\n        /// append ///\r\n        for (const row of this._fields)\r\n            for (const child of row)\r\n                this.html.appendChild(child.html);\r\n        this.html.style.gridTemplateColumns = `repeat(${this._fields.length}, auto)`;\r\n    }\r\n    addEventListener(event, callback) {\r\n        for (const row of this._fields)\r\n            for (const child of row)\r\n                child.addEventListener(event, callback);\r\n    }\r\n    //// PATHFINDING ////\r\n    findPath(_start = this._start, _end = this._end, maximum = Infinity) {\r\n        // console.log(_start, _end)\r\n        /// translate positions to nodes ///\r\n        if (_start.x != undefined || _start.y != undefined)\r\n            _start = this.find(_start);\r\n        if (_end.x != undefined || _end.y != undefined)\r\n            _end = this.find(_end);\r\n        let openList = [_start];\r\n        let closedList = [];\r\n        let result = {};\r\n        let repeats = 0;\r\n        let allChildren = [];\r\n        while (openList.length != 0) {\r\n            repeats++;\r\n            /// get current node ///\r\n            const currentNode = openList.reduce((min, field) => min.f < field.f\r\n                ? min\r\n                : field);\r\n            openList = Object(_voids__WEBPACK_IMPORTED_MODULE_0__[\"reduceArr\"])(openList, currentNode);\r\n            closedList.push(currentNode);\r\n            /// found the goal ///\r\n            if (Object(_voids__WEBPACK_IMPORTED_MODULE_0__[\"compareObj\"])(currentNode.position, _end.position)) {\r\n                const path = [];\r\n                // console.log(currentNode, 'currentNode')\r\n                let current = currentNode.position;\r\n                let r = 0;\r\n                while (!Object(_voids__WEBPACK_IMPORTED_MODULE_0__[\"compareObj\"])(current, _start.position)) {\r\n                    let next = this.getNode(current).parent;\r\n                    if (Object(_voids__WEBPACK_IMPORTED_MODULE_0__[\"compareObj\"])(next, current))\r\n                        break;\r\n                    path.push(current);\r\n                    current = next;\r\n                }\r\n                result = {\r\n                    // checked : [ ...closedList, ...openList ],\r\n                    checked: Object(_voids__WEBPACK_IMPORTED_MODULE_0__[\"join\"])(closedList, openList),\r\n                    path: path.reverse()\r\n                };\r\n                break;\r\n            }\r\n            /// generate children ///\r\n            const children = this.getNeighbours(currentNode.position);\r\n            // allChildren = [ ...allChildren, ...children ]\r\n            allChildren = Object(_voids__WEBPACK_IMPORTED_MODULE_0__[\"join\"])(allChildren, children);\r\n            for (const childP of children) {\r\n                // console.log(childP)\r\n                const child = this.getNode(childP);\r\n                if (closedList.filter(closed => closed.x == child.x && closed.y == child.y).length)\r\n                    continue;\r\n                /// set f, g and h\r\n                child.g = currentNode.g + 1; // zmienic, jeśli trzeba\r\n                child.h = this.distance(child.position, _end.position);\r\n                child.f = child.g + child.h;\r\n                /// CHild is alredy in openList\r\n                if (openList.filter(open => open.x == child.x && open.y == child.y).length) {\r\n                    const max = Math.max.apply(Math, openList.map(function (o) {\r\n                        return o.g;\r\n                    }));\r\n                    if (child.g > max)\r\n                        continue;\r\n                }\r\n                // add the child to the openlist\r\n                openList.push(child);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    getNeighbours(position) {\r\n        const finalResult = [];\r\n        const result = [];\r\n        const neighbours = [\r\n            { x: 0, y: -1 },\r\n            { x: 1, y: 0 },\r\n            { x: 0, y: 1 },\r\n            { x: -1, y: 0 }\r\n        ];\r\n        for (const neighbour of neighbours) {\r\n            const currentPosition = this.translate(position, neighbour);\r\n            if (this.isOnBoard(currentPosition) && !this.isAlreadyCounted(currentPosition) && !this.isBorder(currentPosition))\r\n                result.push(currentPosition);\r\n        }\r\n        for (const neighbour of result) {\r\n            const { x, y } = neighbour;\r\n            this._fields[y][x].parent = position;\r\n            finalResult.push(this._fields[y][x]);\r\n        }\r\n        return finalResult;\r\n    }\r\n    //// SUPPORTING METHODS ////\r\n    distance(from, to) {\r\n        const { pow } = Math;\r\n        return pow(from.x - to.x, 2) + pow(from.y - to.y, 2);\r\n    }\r\n    find(pos) {\r\n        return this._fields[pos.y][pos.x];\r\n    }\r\n    translate(pos, translation) {\r\n        const clone = Object(_voids__WEBPACK_IMPORTED_MODULE_0__[\"cloneObj\"])(pos);\r\n        clone.x += +translation.x;\r\n        clone.y += +translation.y;\r\n        return clone;\r\n    }\r\n    //// BOOLEANS ////\r\n    isOnBoard(position) {\r\n        if (position.x < 0)\r\n            return false;\r\n        if (position.x >= this._fields.length)\r\n            return false;\r\n        if (position.y < 0)\r\n            return false;\r\n        if (position.y >= this._fields[0].length)\r\n            return false;\r\n        return true;\r\n    }\r\n    isAlreadyCounted(position) {\r\n        return this.find(position).f > 0;\r\n    }\r\n    isBorder(position) {\r\n        const { x, y } = position;\r\n        return this._borders[y][x] == -1;\r\n    }\r\n    getNode(position) {\r\n        return this._fields[position.y][position.x];\r\n    }\r\n    //// SETTERS ////\r\n    set height(height) {\r\n        this._height = height;\r\n    }\r\n    set width(width) {\r\n        this._width = width;\r\n    }\r\n    set borders(borders) {\r\n        this._borders = borders;\r\n    }\r\n    set start(start) {\r\n        this._start = start;\r\n    }\r\n    set end(end) {\r\n        this._end = end;\r\n    }\r\n    //// GETTERS ////\r\n    get html() {\r\n        return this._html.main;\r\n    }\r\n    get height() { return this._height; }\r\n    get width() { return this._width; }\r\n    get fields() { return this._fields; }\r\n    get borders() { return this._borders; }\r\n    get start() { return this._start; }\r\n    get end() { return this._end; }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/pathfind/Matrix.ts?");

/***/ }),

/***/ "./src/pathfind/Node.ts":
/*!******************************!*\
  !*** ./src/pathfind/Node.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PathNode; });\n/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../defaults */ \"./src/defaults.ts\");\nconsole.log('loaded : Node.ts');\r\n\r\nclass PathNode {\r\n    //// MAIN ////\r\n    constructor(props) {\r\n        //// PRIVATE VARS ////\r\n        /// distance and heuristic ///\r\n        this._g = 0;\r\n        this._h = 0;\r\n        /// final cost ///\r\n        this._f = 0;\r\n        /// node position ///\r\n        this._position = {\r\n            x: 0,\r\n            y: 0\r\n        };\r\n        /// is already fill ///\r\n        this._isBorder = false;\r\n        //// HTML ////\r\n        this._html = {\r\n            generate: false,\r\n            main: document.createElement('div'),\r\n            g: document.createElement('div'),\r\n            h: document.createElement('div'),\r\n            f: document.createElement('div'),\r\n            ball: document.createElement('div')\r\n        };\r\n        /// ///\r\n        this._ball = {\r\n            color: -1\r\n        };\r\n        this._position = props.position || {\r\n            x: props.x || this._position.x,\r\n            y: props.y || this._position.y\r\n        };\r\n        this._html.generate = props.generate || this._html.generate;\r\n        this._parent = props.parent;\r\n        // console.log(this._html.generate)\r\n        if (this._html.generate)\r\n            this.generateHtml();\r\n    }\r\n    //// VOIDS ////\r\n    reset() {\r\n        this.g = 0;\r\n        this.h = 0;\r\n        this.f = 0;\r\n        this._parent = undefined;\r\n        if (this._html.generate)\r\n            this.resetHtml();\r\n    }\r\n    //// HTML VOIDS ////\r\n    generateHtml() {\r\n        this._html.g.classList.add('matrix__g');\r\n        this._html.h.classList.add('matrix__h');\r\n        this._html.f.classList.add('matrix__f');\r\n        this._html.ball.classList.add('matrix__ball');\r\n        this._html.main.classList.add('matrix__field');\r\n        this.html.appendChild(this._html.g);\r\n        this.html.appendChild(this._html.h);\r\n        this.html.appendChild(this._html.f);\r\n        this.html.appendChild(this._html.ball);\r\n        this.reset();\r\n    }\r\n    resetHtml() {\r\n        this.html.className = \"matrix__field\";\r\n        if (this.isBorder) {\r\n            this.html.classList.add('matrix__field--border');\r\n            this._html.ball.classList.add('matrix__ball--show');\r\n            this.color = this._ball.color;\r\n            // this._html.ball.style.backgroundColor = defaults.colors[ this._ball.color ]\r\n        }\r\n        else {\r\n            this._html.ball.classList.remove('matrix__ball--show');\r\n        }\r\n    }\r\n    addEventListener(event, callback) {\r\n        this.html.addEventListener(event, e => {\r\n            callback(e, this);\r\n        });\r\n    }\r\n    //// GETTERS ////\r\n    get html() {\r\n        return this._html.main;\r\n    }\r\n    get parent() { return this._parent; }\r\n    get position() { return this._position; }\r\n    get positionJSON() { return JSON.stringify(this._position); }\r\n    get x() { return this._position.x; }\r\n    get y() { return this._position.y; }\r\n    get g() { return this._g; }\r\n    get h() { return this._h; }\r\n    get f() { return this._f; }\r\n    get isBorder() { return this._isBorder; }\r\n    get classList() { return this.html.classList; }\r\n    get ball() { return this._ball; }\r\n    get color() { return this._ball.color; }\r\n    //// SETTERS ////\r\n    set parent(v) { this._parent = v; }\r\n    set x(v) { this._position.x = v; }\r\n    set y(v) { this._position.y = v; }\r\n    set g(v) {\r\n        this._g = v;\r\n        if (this._html.generate)\r\n            this._html.g.innerHTML = `${v}`;\r\n    }\r\n    set h(v) {\r\n        this._h = v;\r\n        if (this._html.generate)\r\n            this._html.h.innerHTML = `${v}`;\r\n    }\r\n    set f(v) {\r\n        this._f = v;\r\n        if (this._html.generate)\r\n            this._html.f.innerHTML = `${v}`;\r\n    }\r\n    set isBorder(v) {\r\n        this._isBorder = v;\r\n    }\r\n    set color(v) {\r\n        let color = v >= 0 && v < _defaults__WEBPACK_IMPORTED_MODULE_0__[\"default\"].colors.length\r\n            ? _defaults__WEBPACK_IMPORTED_MODULE_0__[\"default\"].colors[v]\r\n            : \"\";\r\n        if (color) {\r\n            this._html.ball.style.filter = `drop-shadow( 4px 4px 0 ${color})`;\r\n        }\r\n        else {\r\n            this.isBorder = false;\r\n            this._html.ball.style.filter = '';\r\n        }\r\n        this._html.ball.style.backgroundColor = color;\r\n        this._ball.color = v;\r\n    }\r\n    set ball(v) {\r\n        if (this.isBorder || v.color < 0 && v.color >= _defaults__WEBPACK_IMPORTED_MODULE_0__[\"default\"].colors.length) {\r\n            this._ball = { color: -1 };\r\n            this._html.ball.classList.remove('matrix__ball--show');\r\n            // this._html.ball.classList.remove('matrix__ball')\r\n            this._html.ball.style.backgroundColor = '';\r\n            this._html.ball.style.filter = '';\r\n        }\r\n        else {\r\n            // this._html.ball.classList.add('matrix__ball')\r\n            this._html.ball.classList.add('matrix__ball--show');\r\n            //// UNCOMMENT THIS IF SMTH GOES WRONG ////\r\n            // this.color = v.color\r\n            // const color =  defaults.colors[v.color]\r\n            // this._html.ball.style.backgroundColor = color\r\n            // this._html.ball.style.filter = `drop-shadow( 4px 4px 0 ${color})`\r\n        }\r\n        this.color = v.color;\r\n        this._ball = Object.assign({}, v);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/pathfind/Node.ts?");

/***/ }),

/***/ "./src/voids.ts":
/*!**********************!*\
  !*** ./src/voids.ts ***!
  \**********************/
/*! exports provided: getRandom, reduceArr, compareObj, join, cloneObj */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRandom\", function() { return getRandom; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reduceArr\", function() { return reduceArr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compareObj\", function() { return compareObj; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"join\", function() { return join; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cloneObj\", function() { return cloneObj; });\nconsole.log('loaded : voids.ts');\r\nconst getRandom = (min, max) => {\r\n    min = Math.ceil(min);\r\n    max = Math.floor(max);\r\n    return Math.floor(Math.random() * (max - min)) + min;\r\n};\r\nconst reduceArr = (arr, item) => {\r\n    const index = arr.indexOf(item);\r\n    // console.log( 'index', index)\r\n    if (index > -1)\r\n        arr.splice(index, 1);\r\n    return arr;\r\n};\r\nconst compareObj = (first, second) => {\r\n    return JSON.stringify(first) == JSON.stringify(second);\r\n};\r\nconst join = (first, second) => {\r\n    const result = [];\r\n    first.filter(v => result.push(v));\r\n    second.filter(v => result.push(v));\r\n    return result;\r\n};\r\nconst cloneObj = (obj) => JSON.parse(JSON.stringify(obj));\r\n\n\n//# sourceURL=webpack:///./src/voids.ts?");

/***/ })

/******/ });